{"version":3,"file":"smartFilterTextureBlock.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Dual/smartFilterTextureBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes\";\nimport { CurrentScreenBlock } from \"./currentScreenBlock\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { InputBlock } from \"../Input/inputBlock\";\nimport type { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\nimport type { NodeMaterial } from \"../../nodeMaterial\";\nimport { ScreenSizeBlock } from \"../Fragment/screenSizeBlock\";\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\nimport type { Scene } from \"core/scene\";\n\n/** @internal */\nexport const SfeModeDefine = \"USE_SFE_FRAMEWORK\";\n\n/**\n * Base block used for creating Smart Filter shader blocks for the SFE framework.\n * This block extends the functionality of CurrentScreenBlock, as both are used\n * to represent arbitrary 2D textures to compose, and work similarly.\n */\nexport class SmartFilterTextureBlock extends CurrentScreenBlock {\n    /**\n     * A boolean indicating whether this block should be the main input for the SFE pipeline.\n     * If true, it can be used in SFE for auto-disabling.\n     */\n    @editableInPropertyPage(\"Is Main Input\", PropertyTypeForEdition.Boolean, undefined, { notifiers: { rebuild: true } })\n    public isMainInput: boolean = false;\n\n    /**\n     * Create a new SmartFilterTextureBlock\n     * @param name defines the block name\n     */\n    public constructor(name: string) {\n        super(name);\n    }\n\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    public override getClassName() {\n        return \"SmartFilterTextureBlock\";\n    }\n\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    public override initialize(state: NodeMaterialBuildState) {\n        super.initialize(state);\n\n        this._samplerName = state._getFreeVariableName(this.name);\n\n        if (state.sharedData.nodeMaterial.mode !== NodeMaterialModes.SFE) {\n            state.sharedData.raiseBuildError(\"SmartFilterTextureBlock should not be used outside of SFE mode.\");\n        }\n\n        if (state.sharedData.nodeMaterial.shaderLanguage !== ShaderLanguage.GLSL) {\n            state.sharedData.raiseBuildError(\"WebGPU is not supported by SmartFilterTextureBlock.\");\n        }\n\n        // Tell FragmentOutputBlock ahead of time to store the final color in a temp variable\n        if (!state._customOutputName && state.target === NodeMaterialBlockTargets.Fragment) {\n            state._customOutputName = \"outColor\";\n        }\n\n        // Annotate uniforms of InputBlocks and bindable blocks with their current values\n        if (!state.sharedData.formatConfig.getUniformAnnotation) {\n            state.sharedData.formatConfig.getUniformAnnotation = (name: string) => {\n                for (const block of state.sharedData.nodeMaterial.attachedBlocks) {\n                    if (block instanceof InputBlock && block.isUniform && block.associatedVariableName === name) {\n                        return this._generateInputBlockAnnotation(block);\n                    }\n                    if (block instanceof ScreenSizeBlock && block.associatedVariableName === name) {\n                        return this._generateScreenSizeBlockAnnotation();\n                    }\n                }\n                return \"\";\n            };\n        }\n\n        // Do our best to clean up variable names, as they will be used as display names.\n        state.sharedData.formatConfig.formatVariablename = (n: string) => {\n            let name = n;\n\n            const hasUnderscoredPrefix = name.length > 1 && name[1] === \"_\";\n            if (hasUnderscoredPrefix) {\n                name = name.substring(2);\n            }\n\n            return name.replace(/[^a-zA-Z]+/g, \"\");\n        };\n    }\n\n    private _generateInputBlockAnnotation(inputBlock: InputBlock): string {\n        const value = inputBlock.valueCallback ? inputBlock.valueCallback() : inputBlock.value;\n        return `// { \"default\": ${JSON.stringify(value)} }\\n`;\n    }\n\n    private _generateScreenSizeBlockAnnotation(): string {\n        return `// { \"autoBind\": \"outputResolution\" }\\n`;\n    }\n\n    protected override _getMainUvName(state: NodeMaterialBuildState): string {\n        // Get the ScreenUVBlock's name, which is required for SFE and should be vUV.\n        // NOTE: In the future, when we move to vertex shaders, update this to check for the nearest vec2 varying output.\n        const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\");\n        if (!screenUv || !screenUv.isAnAncestorOf(this)) {\n            state.sharedData.raiseBuildError(\"SmartFilterTextureBlock: 'postprocess_uv' attribute from ScreenUVBlock is required.\");\n            return \"\";\n        }\n        return screenUv.associatedVariableName;\n    }\n\n    protected override _emitUvAndSampler(state: NodeMaterialBuildState): void {\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            // Wrap the varying in a define, as it won't be needed in SFE.\n            state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2, SfeModeDefine, true);\n\n            // Append `// main` to denote this as the main input texture to composite\n            const annotation = this.isMainInput ? \"// main\" : undefined;\n            state._emit2DSampler(this._samplerName, undefined, undefined, annotation);\n        }\n    }\n\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\n        if (!this.uv.isConnected) {\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\" && additionalFilteringInfo(b));\n\n            if (!uvInput) {\n                uvInput = new InputBlock(\"uv\");\n                uvInput.setAsAttribute(\"postprocess_uv\");\n            }\n            uvInput.output.connectTo(this.uv);\n        }\n    }\n\n    protected override _buildBlock(state: NodeMaterialBuildState) {\n        super._buildBlock(state);\n\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            // Add the header JSON for the SFE block\n            if (!state._injectAtTop) {\n                state._injectAtTop = `// { \"smartFilterBlockType\": \"${state.sharedData.nodeMaterial.name}\", \"namespace\": \"Babylon.NME.Exports\" }`;\n            }\n\n            // Convert the main fragment function into a helper function, to later be inserted in an SFE pipeline.\n            if (!state._customEntryHeader) {\n                state._customEntryHeader += `#ifdef ${SfeModeDefine}\\n`;\n                state._customEntryHeader += `vec4 nmeMain(vec2 ${this._mainUVName}) { // main\\n`;\n                state._customEntryHeader += `#else\\n`;\n                state._customEntryHeader += `void main(void) {\\n`;\n                state._customEntryHeader += `#endif\\n`;\n                state._customEntryHeader += `vec4 outColor = vec4(0.0);\\n`;\n            }\n\n            if (!state._injectAtEnd) {\n                state._injectAtEnd += `\\n#ifndef ${SfeModeDefine}\\n`;\n                state._injectAtEnd += `gl_FragColor = outColor;\\n`;\n                state._injectAtEnd += `#else\\n`;\n                state._injectAtEnd += `return outColor;\\n`;\n                state._injectAtEnd += `#endif\\n`;\n            }\n        }\n\n        return this;\n    }\n\n    public override serialize(): any {\n        const serializationObject = super.serialize();\n        serializationObject.isMainInput = this.isMainInput;\n        return serializationObject;\n    }\n\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.isMainInput = serializationObject.isMainInput;\n    }\n}\n\nRegisterClass(\"BABYLON.SmartFilterTextureBlock\", SmartFilterTextureBlock);\n"]}