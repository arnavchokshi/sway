import { __decorate } from "../../../tslib.es6.js";
import { Vector2, Vector3 } from "../../../Maths/math.vector.js";
import { RegisterClass } from "../../../Misc/typeStore.js";
import { NodeParticleBlockConnectionPointTypes } from "../Enums/nodeParticleBlockConnectionPointTypes.js";
import { NodeParticleBlock } from "../nodeParticleBlock.js";
import { Color4 } from "../../../Maths/math.color.js";
import { ParticleRandomBlockLocks } from "./particleRandomBlock.js";
import { editableInPropertyPage } from "../../../Decorators/nodeDecorator.js";
/**
 * Block used to pick a value randomly from a range
 */
export class RandomRangeBlock extends NodeParticleBlock {
    /**
     * Create a new RandomRangeBlock
     * @param name defines the block name
     */
    constructor(name) {
        super(name);
        this._currentLockId = -2;
        /**
         * Gets or sets a value indicating if that block will lock its value for a specific event
         */
        this.lockMode = ParticleRandomBlockLocks.PerParticle;
        this.registerInput("min", NodeParticleBlockConnectionPointTypes.AutoDetect);
        this.registerInput("max", NodeParticleBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.BasedOnInput);
        this.output._typeConnectionSource = this.min;
        this._linkConnectionTypes(0, 1);
        const excludedConnectionPointTypes = [
            NodeParticleBlockConnectionPointTypes.Matrix,
            NodeParticleBlockConnectionPointTypes.Particle,
            NodeParticleBlockConnectionPointTypes.Texture,
            NodeParticleBlockConnectionPointTypes.System,
            NodeParticleBlockConnectionPointTypes.FloatGradient,
            NodeParticleBlockConnectionPointTypes.Color4Gradient,
            NodeParticleBlockConnectionPointTypes.Vector2Gradient,
            NodeParticleBlockConnectionPointTypes.Vector3Gradient,
        ];
        this.min.excludedConnectionPointTypes.push(...excludedConnectionPointTypes);
        this.max.excludedConnectionPointTypes.push(...excludedConnectionPointTypes);
    }
    /**
     * Gets the min input component
     */
    get min() {
        return this._inputs[0];
    }
    /**
     * Gets the max input component
     */
    get max() {
        return this._inputs[1];
    }
    /**
     * Gets the output component
     */
    get output() {
        return this._outputs[0];
    }
    /**
     * Gets the current class name
     * @returns the class name
     */
    getClassName() {
        return "RandomRangeBlock";
    }
    /**
     * Builds the block
     */
    _build() {
        let func = null;
        this._currentLockId = -2;
        switch (this.min.type) {
            case NodeParticleBlockConnectionPointTypes.Float:
            case NodeParticleBlockConnectionPointTypes.Int:
                func = (state) => {
                    const minValue = this.min.getConnectedValue(state);
                    const maxValue = this.max.getConnectedValue(state);
                    return Math.random() * (maxValue - minValue) + minValue;
                };
                break;
            case NodeParticleBlockConnectionPointTypes.Vector2:
                func = (state) => {
                    const minValue = this.min.getConnectedValue(state);
                    const maxValue = this.max.getConnectedValue(state);
                    return new Vector2(Math.random() * (maxValue.x - minValue.x) + minValue.x, Math.random() * (maxValue.y - minValue.y) + minValue.y);
                };
                break;
            case NodeParticleBlockConnectionPointTypes.Vector3:
                func = (state) => {
                    const minValue = this.min.getConnectedValue(state);
                    const maxValue = this.max.getConnectedValue(state);
                    return new Vector3(Math.random() * (maxValue.x - minValue.x) + minValue.x, Math.random() * (maxValue.y - minValue.y) + minValue.y, Math.random() * (maxValue.z - minValue.z) + minValue.z);
                };
                break;
            case NodeParticleBlockConnectionPointTypes.Color4:
                func = (state) => {
                    const minValue = this.min.getConnectedValue(state);
                    const maxValue = this.max.getConnectedValue(state);
                    return new Color4(Math.random() * (maxValue.r - minValue.r) + minValue.r, Math.random() * (maxValue.g - minValue.g) + minValue.g, Math.random() * (maxValue.b - minValue.b) + minValue.b, Math.random() * (maxValue.a - minValue.a) + minValue.a);
                };
                break;
        }
        this.output._storedFunction = (state) => {
            let lockId = 0;
            switch (this.lockMode) {
                case ParticleRandomBlockLocks.PerParticle:
                    lockId = state.particleContext?.id || -1;
                    break;
                case ParticleRandomBlockLocks.PerSystem:
                    lockId = state.buildId || 0;
                    break;
            }
            if (this._currentLockId !== lockId) {
                if (this.lockMode !== ParticleRandomBlockLocks.None) {
                    this._currentLockId = lockId;
                }
                this.output._storedValue = func(state);
            }
            return this.output._storedValue;
        };
    }
    /**
     * Serializes this block in a JSON representation
     * @returns the serialized block object
     */
    serialize() {
        const serializationObject = super.serialize();
        serializationObject.lockMode = this.lockMode;
        return serializationObject;
    }
    _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        if (serializationObject.lockMode !== undefined) {
            this.lockMode = serializationObject.lockMode;
        }
    }
}
__decorate([
    editableInPropertyPage("LockMode", 4 /* PropertyTypeForEdition.List */, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
            { label: "None", value: ParticleRandomBlockLocks.None },
            { label: "Per particle", value: ParticleRandomBlockLocks.PerParticle },
            { label: "Per system", value: ParticleRandomBlockLocks.PerSystem },
        ],
    })
], RandomRangeBlock.prototype, "lockMode", void 0);
RegisterClass("BABYLON.RandomRangeBlock", RandomRangeBlock);
//# sourceMappingURL=randomRangeBlock.js.map